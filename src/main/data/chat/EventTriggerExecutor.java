package main.data.chat;

import main.data.Data;
import main.data.event.InternalEvent;
import main.data.event.environment.EnvironmentEvent;
import main.data.event.environment.EnvironmentEventFactory;
import main.data.event.environment.EnvironmentEventType;
import main.data.event.environment.GiveItemEvent;
import main.entity.actor.Actor;
import main.entity.actor.ActorType;
import main.entity.chat.ChatResponse;
import main.entity.chat.CompareOperator;
import main.entity.event.Trigger;
import main.entity.item.Inventory;
import main.entity.item.Item;
import main.entity.item.ItemSource;
import main.entity.item.ItemType;
import main.entity.item.equipment.Equipment;

public class EventTriggerExecutor
{
	//TODO: I may send this through the engine instead if enough logic is repeated.
	//		However, since chatting is agnostic of game time/flow (that is, you can't be interrupted), there's no harm in changing things directly,
	//		since nothing needs to be queued
	//		This could be a problem for triggers that don't come from chats, but we'll see how it all goes.  For those, I suppose add new events to the queue.
	private Data data = null;
	
	private static EventTriggerExecutor instance = null;
	
	private EventTriggerExecutor() {}
	
	public static EventTriggerExecutor getInstance()
	{
		if (instance == null)
			instance = new EventTriggerExecutor();
		
		return instance;
	}
	
	public void setData(Data data)
	{
		this.data = data;
	}
	
	public void executeChatResponseTriggers(ChatResponse response)
	{
		for (Trigger trigger : response.getTriggers())
		{
			executeTrigger(trigger);
		}
	}

	public void executeTrigger(Trigger trigger)
	{
		if (trigger == null)
			return;
		
		String detailString = trigger.getComparison();
		int detailNumber = 0;
		
		try
		{
			detailNumber = Integer.parseInt(detailString);
		} catch (NumberFormatException nfe) {}
		
		Actor player = data.getPlayer();
		
		switch (trigger.getType())
		{
		case CHANGE_HP:
			changePlayerHp(player, detailNumber);
			break;
		case GET_ITEM_FROM:
			receiveItem(trigger);
			break;
		case GIVE_ITEM_TO:
			giveItem(trigger);
			break;
		default:
			break;
		}
	}

	private void receiveItem(Trigger trigger)
	{
		String giverActor = trigger.getModifier();
		String receiverActor = "PLAYER";
		transferItem(giverActor, receiverActor, trigger);
	}
	
	private void giveItem(Trigger trigger)
	{
		String giverActor = "PLAYER";
		String receiverActor = trigger.getModifier();
		transferItem(giverActor, receiverActor, trigger);
	}
				
	private void transferItem(String giverActorType, String receiverActorType, Trigger trigger)
	{
		String itemToTransfer = trigger.getValue();
		String itemCount = trigger.getComparison();
		
		String availableItems = RequirementValidator.getInstance().getValueToCheckForActorHasItem(giverActorType, itemToTransfer);
		boolean sourceActorHasEnoughItemsToGive = RequirementValidator.getInstance().checkRequirement(CompareOperator.GREATER_THAN_OR_EQUAL, itemCount, availableItems);
		
		int itemsToGive = Integer.parseInt(itemCount);
		
		//still give as many as possible
		if (!sourceActorHasEnoughItemsToGive)
			itemsToGive = Integer.parseInt(availableItems);
		
		if (itemsToGive == 0)
			return;
		
		Actor giver = data.getFirstActorOfType(ActorType.fromString(giverActorType));
		Actor receiver = data.getFirstActorOfType(ActorType.fromString(receiverActorType));
		ItemType itemType = ItemType.fromString(itemToTransfer);
		ItemSource itemSource = giver.getFirstAvailableSourceForItem(itemType);
		int itemIndex = getIndexOfItemToTransfer(giver, itemSource, itemType);
		
		if (itemIndex == -1)
			return;
			
		EnvironmentEvent event = new GiveItemEvent(giver, receiver, itemSource, itemIndex, null);
		triggerEvent(event);
	}

	private int getIndexOfItemToTransfer(Actor giver, ItemSource itemSource, ItemType itemType)
	{
		Inventory inventory;
		Equipment equipment;
		
		switch (itemSource)	//TODO: add more if they become relevant
		{
		case MATERIAL:
			inventory = giver.getMaterials();
			break;
		case PACK:
			inventory = giver.getStoredItems();
			break;
		case MAGIC:
			equipment = giver.getMagicItems();
			Item item = equipment.getFirstItemOfType(itemType);
			return equipment.getIndexOfItem(item);
		default:
			return -1;
		}
		
		Item item = inventory.getFirstItemOfType(itemType);
		return inventory.indexOf(item);
	}

	private void changePlayerHp(Actor player, int amount)
	{
		EnvironmentEvent event = EnvironmentEventFactory.generateNewEvent(null, EnvironmentEventType.HP_CHANGE, player, amount);
		triggerEvent(event);
	}
	
	//used for instantaneous events; delayed ones probably should be added to the event queue (which will also send it through Engine): data.getEventQueue().add(event);
	//also note that there will be no messages related to this, since those are generated by the engine (could be a trivial issue for, say, giving items)
	private void triggerEvent(EnvironmentEvent event)
	{
		for (InternalEvent iEvent : event.trigger())
		{
			data.receiveInternalEvent(iEvent);
		}
	}
}
